"""
Helper functions used by ACT-R modules.
"""

import collections
import re
import math
import numpy as np

#for querying buffers

_BUSY = "busy"
_FREE = "free"
_ERROR = "error" 
_VISAUTOBUFFERING = "auto_buffering" 

#for rules

ACTRVARIABLE = "="
ACTRVARIABLER = "\=" #used for regex
ACTRVALUE = "!"
ACTRVALUER = "\!" #used for regex
ACTRNEG = "~"
ACTRNEGR = "\~" #used for regex
ACTRRETRIEVE = "+"
ACTRRETRIEVER = "\+" #used for regex

#for Events

Event = collections.namedtuple('Event', 'time proc action')

_UNKNOWN = "UNKNOWN"
_PROCEDURAL = "PROCEDURAL"
_EMPTY = ""
_ENV = "ENVIRONMENT"

def roundtime(time):
    return round(time, 4)

##############class for ACT-R Exceptions##############

class ACTRError(Exception):
    """
    Exception specific to ACT-R.
    """

#############utilities for chunks######################################

def splitting(info):
    """
    Splitting info into variables, negative variables, values and negative values. Used in chunks.

    Info could either be a string, e.g., '=x~=y!2', or a special chunk 'variablesvalues', e.g., Chunk('_variablesvalues', variables='x', negvariables='y', values=2). Alternatively, info could consist only of a value.
    """
    varval = {"variables": set(), "values": set(), "negvariables": set(), "negvalues": set()}
    try: #assume it's a string
        varval["variables"] = set(re.findall("(?<="+"(?<!"+ACTRNEGR+")"+ ACTRVARIABLER+").*?(?=$|"+ACTRNEGR+"|"+ACTRVALUER+"|"+ACTRVARIABLER+")", info))
        varval["values"] = set(re.findall("(?<="+"(?<!"+ACTRNEGR+")"+ ACTRVALUER+").*?(?=$|"+ACTRNEGR+"|"+ACTRVALUER+"|"+ACTRVARIABLER+")", info))
        varval["negvariables"] = set(re.findall("(?<="+ACTRNEGR+ ACTRVARIABLER+").*?(?=$|"+ACTRNEGR+"|"+ACTRVALUER+"|"+ACTRVARIABLER+")", info))
        varval["negvalues"] = set(re.findall("(?<="+ACTRNEGR+ ACTRVALUER+").*?(?=$|"+ACTRNEGR+"|"+ACTRVALUER+"|"+ACTRVARIABLER+")", info))
    except TypeError:
        try: #assume it's a attr-val chunk
            if info.typename == "_variablesvalues":
                for x in info.removeempty():
                    if type(x[1]) == tuple:
                        varval[x[0]] = set(x[1])
                    else:
                        varval[x[0]] = set([x[1]])
        except AttributeError: #it's just values
            pass
    assert len(set(varval["values"])) <= 1, "Any attribute must have at most one value"
    assert len(set(varval["variables"])) <= 1, "Any attribute must have at most one variable"
    if not any(varval.values()):
        varval["values"] = set([info]) #varval empty -> only values present

    return varval

def get_similarity(d, val1, val2):
    """
    Gets similarity for partial matching.
    """
    dis = d.get(tuple((val2, val1)), -1) #-1 is the default value
    return dis

#############utilities for rules######################################

def check_bound_vars(actrvariables, elem):
    """
    Check that elem is a bound variable, or not a variable. If the test goes through, return elem.
    """
    result = actrvariables.get(elem, elem)
    try:
        if splitting(result).get("variables"):
            raise ACTRError("Object '%s' is a variable that is not bound to any value; this is illegal in ACT-R" % splitting(result).get("variables").pop()) #is this correct? maybe in some special cases binding only in RHS should be allowed? If so this should be adjusted in productions.py
        if splitting(result).get("negvariables"):
            raise ACTRError("Object '%s' is a variable that is not bound to any value; this is illegal in ACT-R" % splitting(result).get("negvariables"))
    except TypeError:
        pass
    return result

def modify_utilities(time, reward, rules, model_parameters):
    """
    Returns a new dict of rules, updated with newly calculated utilites for rules whose firing led to reward.
    """
    for rulename in rules:
        if rules[rulename]["selecting_time"] != []:
            for t in rules[rulename]["selecting_time"]:
                utility_time = time-t
                rules[rulename]["utility"] = round(rules[rulename]["utility"] + model_parameters["utility_alpha"]*(reward-utility_time-rules[rulename]["utility"]), 4)
            rules[rulename]["selecting_time"] = []

def calculate_setting_time(updated, model_parameters):
    """
    Calculates time to set a chunk in a buffer.
    """
    try:
        val = updated.set_delay
    except AttributeError:
        val = 0
    return val

#############utilities for baselevel learning and noise######################################

def baselevel_learning(current_time, times, bll, decay):
    """
    Calculates base-level learning: B_i = ln(sum(t_j^{-decay})) for t_j = current_time - t for t in times.
    """
    B = 0
    if bll:
        B = math.log(sum((current_time - x) ** (-decay) for x in times))
    return B

def calculate_instantanoues_noise(instantaneous_noise):
    """
    Calculates noise, generated by logistic distribution with mean 0 and variance = ( pi^2/3 ) * s^2 where s = instantaneous_noise.
    """
    assert instantaneous_noise >= 0, "Instantaneous noise must be positive"
    if instantaneous_noise == 0:
        return 0
    else:
        return np.random.logistic(0, instantaneous_noise, 1)[0]

#############utilities for source activation######################################

def weigh_buffer(chunk, weight_k):
    """
    Calculates w_{kj}=w_k/n_k. That is, you supply chunk and its activation w_k and it divides w_k by the number of chunks in w_k.
    """
    n_k = len(tuple(find_chunks(chunk)))
    if n_k == 0:
        weight_kj = 0
    else:
        weight_kj = weight_k/n_k
    return weight_kj

def find_chunks(chunk):
    """
    Find chunks as values in slots in the chunk chunk.
    """
    return (x[1] for x in chunk if x[1] != None and not isinstance(x[1], str))

def calculate_strength_association(chunk, otherchunk, dm, strength_of_association):
    """
    Calculates S_{ji} = S - ln((1+slots_j)/slots_ij), where j=chunk, i=otherchunk
    """
    if chunk != otherchunk and chunk not in otherchunk._asdict().values():
        return 0
    else:
        slots_j = 0
        for each in dm:
            if chunk in set(x[1] for x in each):
                slots_j += list(x[1] for x in each).count(chunk)
    slots_ij = list(otherchunk._asdict().values()).count(chunk)
    return strength_of_association - math.log((1 + slots_j)/max(1, slots_ij))

def spreading_activation(chunk, buffers, dm, buffer_spreading_activation, strength):
    """
    Calculates spreading activation.
    """
    SA = 0
    for each in buffer_spreading_activation:
        otherchunk = list(buffers[each])[0]
        w_kj = weigh_buffer(otherchunk, buffer_spreading_activation[each])
        s_ji = 0
        for each in find_chunks(otherchunk):
            s_ji += calculate_strength_association(each, chunk, dm, strength)
        SA += w_kj*s_ji
    return SA

##########utilities for subsymbolic retrieval, general###########

def retrieval_success(activation, threshold):
    """
    If retrieval successful, return the element.
    """
    return True if activation >= threshold else False

def retrieval_latency(activation, latency_factor):
    """
    Calculates base-level learning: B_i = ln(sum(t_j^{-decay})) for t_j = current_time - t for t in times.
    """
    return latency_factor*(math.exp(-activation))



###########################################################
#########BELOW: CURRENTLY UNUSED FUNCTIONS#################
###########################################################


def splitting_submodules(string): #currently not used, maybe eventually !!!not used
    """
    Splitting info into variables and retrievals. Currently not used, but could be implemented for production rules.
    """
    variables = re.findall("(?<="+ ACTRVARIABLER+").*?(?=$)", string)
    retrievals = re.findall("(?<="+ ACTRRETRIEVER+").*?(?=$)", string)
    return {"variables": set(variables), "retrievals": set(retrievals)}

